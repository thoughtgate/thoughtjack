"use strict";(globalThis.webpackChunkthoughtjack_docs_site=globalThis.webpackChunkthoughtjack_docs_site||[]).push([[7165],{5282(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"explanation/phase-engine","title":"Phase Engine Design","description":"State machine concepts, atomic transitions, and timer mechanics","source":"@site/docs/explanation/phase-engine.mdx","sourceDirName":"explanation","slug":"/explanation/phase-engine","permalink":"/docs/explanation/phase-engine","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Phase Engine Design","sidebar_position":3,"description":"State machine concepts, atomic transitions, and timer mechanics"},"sidebar":"docs","previous":{"title":"Architecture","permalink":"/docs/explanation/architecture"},"next":{"title":"Explanation","permalink":"/docs/explanation/"}}');var i=t(4848),r=t(8453);const a={title:"Phase Engine Design",sidebar_position:3,description:"State machine concepts, atomic transitions, and timer mechanics"},o="Phase Engine Design",c={},h=[{value:"State machine model",id:"state-machine-model",level:2},{value:"Phase lifecycle",id:"phase-lifecycle",level:2},{value:"Response-before-transition invariant",id:"response-before-transition-invariant",level:2},{value:"Atomic state",id:"atomic-state",level:2},{value:"Trigger evaluation",id:"trigger-evaluation",level:2},{value:"Event-count triggers",id:"event-count-triggers",level:3},{value:"Time-based triggers",id:"time-based-triggers",level:3},{value:"Content-matching triggers",id:"content-matching-triggers",level:3},{value:"Timeout behavior",id:"timeout-behavior",level:2},{value:"Per-connection vs. global state",id:"per-connection-vs-global-state",level:2},{value:"Entry action ordering",id:"entry-action-ordering",level:2},{value:"Terminal phases",id:"terminal-phases",level:2}];function l(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"phase-engine-design",children:"Phase Engine Design"})}),"\n",(0,i.jsx)(n.p,{children:"The phase engine is the core of ThoughtJack's temporal attack capability. It implements a state machine that progresses through phases based on events, time, and content matching."}),"\n",(0,i.jsx)(n.h2,{id:"state-machine-model",children:"State machine model"}),"\n",(0,i.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e baseline\n    baseline --\x3e phase_1: trigger condition met\n    phase_1 --\x3e phase_2: trigger condition met\n    phase_2 --\x3e phase_N: trigger condition met\n    phase_N --\x3e [*]: terminal phase"}),"\n",(0,i.jsxs)(n.p,{children:["The phase engine is a ",(0,i.jsx)(n.strong,{children:"linear state machine"})," \u2014 phases advance in order from baseline through each configured phase. There are no backward transitions or branching paths. This models the typical attack lifecycle: reconnaissance \u2192 trust building \u2192 escalation \u2192 exploitation."]}),"\n",(0,i.jsx)(n.h2,{id:"phase-lifecycle",children:"Phase lifecycle"}),"\n",(0,i.jsx)(n.p,{children:"Each phase has three aspects:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Trigger"})," \u2014 the condition that advances to the next phase"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Entry actions"})," \u2014 notifications, requests, and log messages fired on entry"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Diffs"})," \u2014 modifications to the tool/resource/prompt sets"]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"graph LR\n    A[Trigger Met] --\x3e B[Response Sent<br/>pre-transition state]\n    B --\x3e C[Phase Index Updated]\n    C --\x3e D[Diffs Applied]\n    D --\x3e E[Entry Actions Fired]"}),"\n",(0,i.jsx)(n.h2,{id:"response-before-transition-invariant",children:"Response-before-transition invariant"}),"\n",(0,i.jsx)(n.p,{children:"The most important design decision in the phase engine:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["The response to the request that triggers a phase transition uses the ",(0,i.jsx)(n.strong,{children:"pre-transition"})," state. The new phase takes effect ",(0,i.jsx)(n.strong,{children:"after"})," the response is sent."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This means:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'If a tool call triggers advancement from "benign" to "exploit", the response to that call comes from the "benign" phase'}),"\n",(0,i.jsxs)(n.li,{children:["The client sees the phase change on the ",(0,i.jsx)(n.strong,{children:"next"})," request, not the triggering one"]}),"\n",(0,i.jsxs)(n.li,{children:["Entry actions (like ",(0,i.jsx)(n.code,{children:"send_notification: notifications/tools/list_changed"}),") fire after the response"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Why? Because real-world attacks operate this way \u2014 the malicious change happens between requests, not within one. This also prevents timing issues where a response might reference tools that don't exist yet."}),"\n",(0,i.jsx)(n.h2,{id:"atomic-state",children:"Atomic state"}),"\n",(0,i.jsxs)(n.p,{children:["The current phase index is stored as an ",(0,i.jsx)(n.code,{children:"AtomicU64"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Phase Index: AtomicU64\n\u251c\u2500\u2500 Load (Relaxed) \u2014 every request reads the current phase\n\u251c\u2500\u2500 Compare-and-swap \u2014 trigger evaluation atomically advances\n\u2514\u2500\u2500 No mutex needed \u2014 lock-free hot path\n"})}),"\n",(0,i.jsx)(n.p,{children:"This design choice matters for HTTP transport with multiple concurrent connections:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Multiple connections can read the current phase simultaneously without contention"}),"\n",(0,i.jsx)(n.li,{children:"Phase transitions are atomic \u2014 no intermediate states are visible"}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"DashMap"})," provides per-connection state for ",(0,i.jsx)(n.code,{children:"per-connection"})," scope"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"trigger-evaluation",children:"Trigger evaluation"}),"\n",(0,i.jsx)(n.p,{children:"Triggers are evaluated on every relevant event. The engine supports three trigger types:"}),"\n",(0,i.jsx)(n.h3,{id:"event-count-triggers",children:"Event-count triggers"}),"\n",(0,i.jsx)(n.p,{children:"The simplest trigger. The engine maintains a counter for the specified event and fires when the count reaches the threshold."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Event: tools/call\nCounter: 0 \u2192 1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 = FIRE\n"})}),"\n",(0,i.jsx)(n.p,{children:"The counter is specific to the trigger's event name. Different phases can count different events."}),"\n",(0,i.jsx)(n.h3,{id:"time-based-triggers",children:"Time-based triggers"}),"\n",(0,i.jsx)(n.p,{children:"Time-based triggers use a timer that starts when the phase is entered. The phase engine checks these triggers at a configurable interval."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Phase entered at T=0\nTimer check at T=100ms: 0.1s < 30s \u2192 not met\nTimer check at T=200ms: 0.2s < 30s \u2192 not met\n...\nTimer check at T=30000ms: 30s >= 30s \u2192 FIRE\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The check interval is controlled by ",(0,i.jsx)(n.code,{children:"THOUGHTJACK_TIMER_INTERVAL_MS"})," (default: 100ms). Lower values increase timer precision but add CPU overhead."]}),"\n",(0,i.jsx)(n.h3,{id:"content-matching-triggers",children:"Content-matching triggers"}),"\n",(0,i.jsx)(n.p,{children:"Content-matching triggers evaluate field matchers against request payloads. All matchers must pass (AND semantics)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Match: args.query contains "password"\n\nRequest 1: args.query = "hello world" \u2192 no match\nRequest 2: args.query = "my password" \u2192 MATCH \u2192 FIRE\n'})}),"\n",(0,i.jsx)(n.p,{children:"Regex patterns are compiled once and cached (up to 256 entries) for performance."}),"\n",(0,i.jsx)(n.h2,{id:"timeout-behavior",children:"Timeout behavior"}),"\n",(0,i.jsx)(n.p,{children:"Event-count triggers support an optional timeout. If the count threshold isn't reached before the timeout elapses:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advance"})," (default): advance to the next phase anyway, even though the count wasn't met"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Abort"}),": stop the phase engine entirely"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'This models scenarios like "wait for 10 tool calls, but if the user is idle for 60 seconds, proceed anyway."'}),"\n",(0,i.jsx)(n.h2,{id:"per-connection-vs-global-state",children:"Per-connection vs. global state"}),"\n",(0,i.jsxs)(n.p,{children:["With HTTP transport, multiple clients connect simultaneously. The ",(0,i.jsx)(n.code,{children:"state_scope"})," setting controls how phase state is shared:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Per-connection"})," (default):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Client A: baseline \u2192 phase_1 \u2192 phase_2\nClient B: baseline \u2192 phase_1         (independent)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Each connection maintains its own phase counter and trigger state. Client A advancing to phase 2 doesn't affect Client B."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Global"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Client A: tools/call (count: 3)\nClient B: tools/call (count: 2)\nCombined count: 5 \u2192 triggers advance for ALL clients\n"})}),"\n",(0,i.jsx)(n.p,{children:"All connections share a single phase counter. Any client's events contribute to the global count."}),"\n",(0,i.jsx)(n.h2,{id:"entry-action-ordering",children:"Entry action ordering"}),"\n",(0,i.jsx)(n.p,{children:"When a phase is entered, actions fire in declaration order:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'on_enter:\n  - log: "Phase entered"                              # 1st\n  - send_notification: "notifications/tools/list_changed"  # 2nd\n  - send_request: { method: "sampling/createMessage" }     # 3rd\n'})}),"\n",(0,i.jsx)(n.p,{children:"Entry actions are fire-and-forget \u2014 the engine doesn't wait for the client to process them before continuing."}),"\n",(0,i.jsx)(n.h2,{id:"terminal-phases",children:"Terminal phases"}),"\n",(0,i.jsxs)(n.p,{children:["The last phase in the ",(0,i.jsx)(n.code,{children:"phases"})," array is the terminal phase. Once entered, no further transitions occur. The server continues operating in the terminal phase state indefinitely."]}),"\n",(0,i.jsx)(n.p,{children:"If no phases are configured, the server operates in the baseline state forever."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);