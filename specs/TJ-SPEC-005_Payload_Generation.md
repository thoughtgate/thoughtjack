# TJ-SPEC-005: Payload Generation

| Metadata | Value |
|----------|-------|
| **ID** | `TJ-SPEC-005` |
| **Title** | Payload Generation |
| **Type** | Core Specification |
| **Status** | Draft |
| **Priority** | **High** |
| **Version** | v1.0.0 |
| **Tags** | `#payloads` `#generate` `#dos` `#fuzzing` `#nested-json` `#unicode` `#garbage` |

## 1. Context & Decision Rationale

This specification defines ThoughtJack's payload generation system ‚Äî the `$generate` directive that creates attack payloads at configuration load time.

### 1.1 Motivation

Handcrafting attack payloads is tedious and error-prone:

| Payload Type | Manual Approach | Problem |
|--------------|-----------------|---------|
| 10,000-level nested JSON | Write `{"a":{"a":{"a":...` by hand | Impossible |
| 100KB of garbage bytes | Copy-paste random data | Inconsistent |
| Unicode attack sequences | Research and encode manually | Easy to get wrong |
| Hash collision strings | Generate offline, paste in | Not reproducible |

The `$generate` directive solves this by declaratively specifying payload characteristics. ThoughtJack generates the actual bytes at config load time.

### 1.2 Design Principles

| Principle | Rationale |
|-----------|-----------|
| **Declarative** | Specify what you want, not how to build it |
| **Deterministic** | Same parameters produce same output (seeded RNG) |
| **Load-time generation** | Generate once, use many times (no runtime overhead) |
| **Safety limits** | Prevent accidental resource exhaustion |
| **Streaming for large payloads** | Don't buffer multi-MB payloads in memory |

### 1.3 Generation vs Behavioral Modes

The `$generate` directive and behavioral modes (TJ-SPEC-004) serve different purposes:

| Aspect | $generate | Behavioral Modes |
|--------|-----------|------------------|
| **What** | Payload content | Delivery mechanism |
| **When** | Config load time | Request/response time |
| **Example** | 10,000-level nested JSON | Byte-by-byte delivery |
| **Scope** | Response content | Server behavior |

They compose: `$generate: nested_json` creates the payload; `delivery: slow_loris` controls how it's sent.

### 1.4 Scope Boundaries

**In scope:**
- Generator interface and implementations
- Parameter validation
- Safety limit enforcement
- Deterministic seeding
- Streaming generation for large payloads
- Caching generated content

**Out of scope:**
- Delivery behaviors (TJ-SPEC-004)
- Configuration parsing (TJ-SPEC-006)
- Response construction (uses generated payloads)

---

## 2. Functional Requirements

### F-001: Generator Interface

The system SHALL define a common interface for payload generators.

**Acceptance Criteria:**
- All generators implement a common trait
- Generators produce bytes or structured JSON
- Generators report size before full generation (for limit checking)
- Generators support streaming for large outputs
- **Generators are factories: `$generate` resolves to a generator object at config load time, NOT materialized bytes**

**IMPORTANT: Lazy Evaluation**

The `$generate` directive in configuration is resolved to a **generator factory object**, not a buffered byte array. This prevents OOM on startup when configs contain large payload definitions like `$generate: { type: garbage, bytes: 1gb }`.

```
Config Load Time:
  $generate: {...}  ‚Üí  Box<dyn PayloadGenerator>  (factory stored, NO bytes generated)

Response Time:
  generator.generate()  ‚Üí  GeneratedPayload::Buffered | ::Streamed  (bytes produced NOW)
```

**Interface:**
```rust
/// Generators are FACTORIES - they don't hold generated bytes
/// The `generate()` method is called at RESPONSE TIME, not config load time
pub trait PayloadGenerator: Send + Sync {
    /// Generate the payload - called at RESPONSE TIME, not config load
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError>;
    
    /// Estimate output size without generating (for limit checking at load time)
    fn estimated_size(&self) -> usize;
    
    /// Get generator name for logging
    fn name(&self) -> &'static str;
    
    /// Whether this generator produces valid JSON
    fn produces_json(&self) -> bool;
}

pub enum GeneratedPayload {
    /// Small payload, fully buffered
    Buffered(Vec<u8>),
    
    /// Large payload, streamed on demand
    Streamed(Box<dyn PayloadStream>),
}

#[async_trait]
pub trait PayloadStream: Send {
    /// Read next chunk of payload
    async fn next_chunk(&mut self) -> Option<Result<Vec<u8>, GeneratorError>>;
    
    /// Total size (if known)
    fn total_size(&self) -> Option<usize>;
}
```

**Config Loader Integration (see TJ-SPEC-006):**

The Config Loader stores generator objects, not bytes:
```rust
pub enum ResolvedContent {
    Static(String),
    Generated(Box<dyn PayloadGenerator>),  // Factory, not bytes!
}
```

### F-002: Nested JSON Generator

The system SHALL generate deeply nested JSON structures.

**Acceptance Criteria:**
- Configurable nesting depth
- Configurable structure type (object, array, mixed)
- Configurable key names for objects
- Produces syntactically valid JSON
- Inner content is configurable or null

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: nested_json
        depth: 10000              # Nesting levels (required)
        structure: object         # object | array | mixed (default: object)
        key: "a"                  # Key name for objects (default: "a")
        inner: null               # Inner value (default: null)
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `depth` | usize | required | Number of nesting levels |
| `structure` | enum | object | `object`, `array`, or `mixed` |
| `key` | String | "a" | Key name at each object level |
| `inner` | Value | null | Value at innermost level |

**Output Examples:**

```json
// structure: object, depth: 3, key: "a", inner: null
{"a":{"a":{"a":null}}}

// structure: array, depth: 3, inner: 42
[[[42]]]

// structure: mixed, depth: 4, key: "x", inner: "payload"
{"x":[{"x":["payload"]}]}
```

**Implementation:**
```rust
pub struct NestedJsonGenerator {
    pub depth: usize,
    pub structure: NestedStructure,
    pub key: String,
    pub inner: serde_json::Value,
}

#[derive(Debug, Clone, Copy)]
pub enum NestedStructure {
    Object,
    Array,
    Mixed,
}

impl PayloadGenerator for NestedJsonGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let mut output = Vec::with_capacity(self.estimated_size());
        
        // Opening brackets
        for i in 0..self.depth {
            match self.structure {
                NestedStructure::Object => {
                    output.extend_from_slice(b"{\"");
                    output.extend_from_slice(self.key.as_bytes());
                    output.extend_from_slice(b"\":");
                }
                NestedStructure::Array => {
                    output.push(b'[');
                }
                NestedStructure::Mixed => {
                    if i % 2 == 0 {
                        output.extend_from_slice(b"{\"");
                        output.extend_from_slice(self.key.as_bytes());
                        output.extend_from_slice(b"\":");
                    } else {
                        output.push(b'[');
                    }
                }
            }
        }
        
        // Inner value
        let inner_json = serde_json::to_vec(&self.inner)?;
        output.extend_from_slice(&inner_json);
        
        // Closing brackets
        for i in (0..self.depth).rev() {
            match self.structure {
                NestedStructure::Object => output.push(b'}'),
                NestedStructure::Array => output.push(b']'),
                NestedStructure::Mixed => {
                    if i % 2 == 0 {
                        output.push(b'}');
                    } else {
                        output.push(b']');
                    }
                }
            }
        }
        
        Ok(GeneratedPayload::Buffered(output))
    }
    
    fn estimated_size(&self) -> usize {
        // Rough estimate: ~6 bytes per object level, ~1 per array level
        let per_level = match self.structure {
            NestedStructure::Object => 5 + self.key.len(),
            NestedStructure::Array => 2,
            NestedStructure::Mixed => 4 + self.key.len() / 2,
        };
        self.depth * per_level + 10  // +10 for inner value
    }
    
    fn name(&self) -> &'static str {
        "nested_json"
    }
    
    fn produces_json(&self) -> bool {
        true
    }
}
```

### F-003: Batch Notifications Generator

The system SHALL generate arrays of JSON-RPC notifications.

**Acceptance Criteria:**
- Configurable batch size
- Configurable notification method
- Configurable notification params
- Produces valid JSON-RPC batch array
- Optional ID generation for requests (not notifications)

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: batch_notifications
        count: 10000              # Number of notifications (required)
        method: "notifications/progress"
        params:                   # Optional params
          progress: 50
          total: 100
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `count` | usize | required | Number of notifications in batch |
| `method` | String | "notifications/message" | Notification method |
| `params` | Value | null | Params for each notification |

**Output Example:**
```json
[
  {"jsonrpc":"2.0","method":"notifications/progress","params":{"progress":50,"total":100}},
  {"jsonrpc":"2.0","method":"notifications/progress","params":{"progress":50,"total":100}},
  ...
]
```

**Implementation:**
```rust
pub struct BatchNotificationsGenerator {
    pub count: usize,
    pub method: String,
    pub params: Option<serde_json::Value>,
}

impl PayloadGenerator for BatchNotificationsGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let notification = serde_json::json!({
            "jsonrpc": "2.0",
            "method": &self.method,
            "params": &self.params,
        });
        
        let single = serde_json::to_string(&notification)?;
        let single_len = single.len();
        
        // For very large batches, use streaming
        if self.count > 10000 {
            return Ok(GeneratedPayload::Streamed(Box::new(
                BatchNotificationStream::new(single, self.count)
            )));
        }
        
        // For smaller batches, buffer
        let mut output = Vec::with_capacity(single_len * self.count + self.count + 2);
        output.push(b'[');
        
        for i in 0..self.count {
            if i > 0 {
                output.push(b',');
            }
            output.extend_from_slice(single.as_bytes());
        }
        
        output.push(b']');
        Ok(GeneratedPayload::Buffered(output))
    }
    
    fn estimated_size(&self) -> usize {
        let notification_size = 50 + self.method.len() + 
            self.params.as_ref().map(|p| p.to_string().len()).unwrap_or(4);
        notification_size * self.count + self.count + 2
    }
    
    fn name(&self) -> &'static str {
        "batch_notifications"
    }
    
    fn produces_json(&self) -> bool {
        true
    }
}
```

### F-004: Garbage Generator

The system SHALL generate random byte sequences.

**Acceptance Criteria:**
- Configurable size in bytes
- Configurable character set (ascii, binary, alphanumeric)
- Deterministic with seed
- Streaming for large sizes

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: garbage
        bytes: 1048576            # Size in bytes (required)
        charset: ascii            # ascii | binary | alphanumeric (default: ascii)
        seed: 12345               # Optional RNG seed for reproducibility
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `bytes` | usize | required | Number of bytes to generate |
| `charset` | enum | ascii | `ascii`, `binary`, or `alphanumeric` |
| `seed` | u64 | 0 | RNG seed for reproducibility |

**Character Sets:**

| Charset | Range | Use Case |
|---------|-------|----------|
| `ascii` | 0x20-0x7E (printable) | Text field overflow |
| `binary` | 0x00-0xFF (all bytes) | Binary parser fuzzing |
| `alphanumeric` | A-Z, a-z, 0-9 | Safe text fuzzing |

**Implementation:**
```rust
pub struct GarbageGenerator {
    pub bytes: usize,
    pub charset: Charset,
    pub seed: u64,
}

#[derive(Debug, Clone, Copy)]
pub enum Charset {
    Ascii,
    Binary,
    Alphanumeric,
}

impl Charset {
    fn sample(&self, rng: &mut impl Rng) -> u8 {
        match self {
            Charset::Ascii => rng.gen_range(0x20..=0x7E),
            Charset::Binary => rng.gen(),
            Charset::Alphanumeric => {
                const CHARS: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                CHARS[rng.gen_range(0..CHARS.len())]
            }
        }
    }
}

impl PayloadGenerator for GarbageGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let mut rng = StdRng::seed_from_u64(self.seed);
        
        // Stream for large payloads
        if self.bytes > 1_000_000 {
            return Ok(GeneratedPayload::Streamed(Box::new(
                GarbageStream::new(self.bytes, self.charset, self.seed)
            )));
        }
        
        let output: Vec<u8> = (0..self.bytes)
            .map(|_| self.charset.sample(&mut rng))
            .collect();
        
        Ok(GeneratedPayload::Buffered(output))
    }
    
    fn estimated_size(&self) -> usize {
        self.bytes
    }
    
    fn name(&self) -> &'static str {
        "garbage"
    }
    
    fn produces_json(&self) -> bool {
        false
    }
}
```

### F-005: Repeated Keys Generator

The system SHALL generate JSON objects with repeated/similar keys for hash collision attacks.

**Acceptance Criteria:**
- Configurable number of keys
- Configurable key length
- Keys designed to collide in common hash implementations
- Valid JSON object output

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: repeated_keys
        count: 10000              # Number of keys (required)
        key_length: 8             # Length of each key (default: 8)
        value: "x"                # Value for each key (default: "x")
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `count` | usize | required | Number of keys |
| `key_length` | usize | 8 | Length of each key |
| `value` | Value | "x" | Value for each key |

**Key Generation:**

Keys are generated sequentially (`k0000000`, `k0000001`, ...) to produce a
large JSON object with many distinct keys.  This is sufficient to stress-test
JSON parser allocation and hash-table resizing without relying on
algorithm-specific collision generation.

> **Future enhancement:** `collision_mode` parameter targeting specific hash
> functions (`djb2`, `fnv1a`) may be added in a later version.

**Implementation:**
```rust
pub struct RepeatedKeysGenerator {
    pub count: usize,
    pub key_length: usize,
    pub value: serde_json::Value,
}

impl PayloadGenerator for RepeatedKeysGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let keys = self.generate_keys();

        let mut output = Vec::new();
        output.push(b'{');

        let value_json = serde_json::to_string(&self.value)?;

        for (i, key) in keys.iter().enumerate() {
            if i > 0 {
                output.push(b',');
            }
            output.push(b'"');
            output.extend_from_slice(key.as_bytes());
            output.extend_from_slice(b"\":");
            output.extend_from_slice(value_json.as_bytes());
        }

        output.push(b'}');
        Ok(GeneratedPayload::Buffered(output))
    }

    fn generate_keys(&self) -> Vec<String> {
        // Sequential keys: k0000000, k0000001, ...
        (0..self.count)
            .map(|i| format!("k{:0width$}", i, width = self.key_length - 1))
            .collect()
    }
    
    fn estimated_size(&self) -> usize {
        // {"key":value,"key":value,...}
        let per_entry = self.key_length + 4 + self.value.to_string().len();
        per_entry * self.count + 2
    }
    
    fn name(&self) -> &'static str {
        "repeated_keys"
    }
    
    fn produces_json(&self) -> bool {
        true
    }
}
```

### F-006: Unicode Spam Generator

The system SHALL generate strings with problematic Unicode sequences.

**Acceptance Criteria:**
- Configurable output size
- Configurable Unicode category (zero-width, RTL, homoglyphs, combining)
- Produces valid UTF-8
- Tests Unicode handling vulnerabilities

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: unicode_spam
        bytes: 10000              # Approximate output size (required)
        category: zero_width      # Category of Unicode chars (required)
        carrier: "safe"           # Text to intersperse (default: none)
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `bytes` | usize | required | Approximate output size |
| `category` | enum | required | Unicode category to use |
| `carrier` | String | "" | Text to intersperse with Unicode |

**Unicode Categories:**

| Category | Characters | Attack Vector |
|----------|------------|---------------|
| `zero_width` | U+200B, U+200C, U+200D, U+FEFF | Hidden text, filter bypass |
| `rtl_override` | U+202E, U+202D, U+202C | Display manipulation |
| `homoglyphs` | Cyrillic/Greek lookalikes | Typosquatting |
| `combining` | U+0300-U+036F | Buffer overflow, display issues |
| `control` | U+0000-U+001F | Parser confusion |
| `emoji_zwj` | Emoji + ZWJ sequences | Length calculation bugs |

**Implementation:**
```rust
pub struct UnicodeSpamGenerator {
    pub bytes: usize,
    pub category: UnicodeCategory,
    pub carrier: String,
}

#[derive(Debug, Clone, Copy)]
pub enum UnicodeCategory {
    ZeroWidth,
    RtlOverride,
    Homoglyphs,
    Combining,
    Control,
    EmojiZwj,
}

impl UnicodeCategory {
    fn chars(&self) -> &'static [char] {
        match self {
            Self::ZeroWidth => &[
                '\u{200B}', // Zero-width space
                '\u{200C}', // Zero-width non-joiner
                '\u{200D}', // Zero-width joiner
                '\u{FEFF}', // Byte order mark
                '\u{2060}', // Word joiner
            ],
            Self::RtlOverride => &[
                '\u{202E}', // Right-to-left override
                '\u{202D}', // Left-to-right override
                '\u{202C}', // Pop directional formatting
                '\u{200F}', // Right-to-left mark
                '\u{200E}', // Left-to-right mark
            ],
            Self::Homoglyphs => &[
                '–∞', // Cyrillic 'a' (U+0430)
                '–µ', // Cyrillic 'e' (U+0435)
                '–æ', // Cyrillic 'o' (U+043E)
                '—Ä', // Cyrillic 'p' (U+0440)
                '—Å', // Cyrillic 'c' (U+0441)
                '—Ö', // Cyrillic 'x' (U+0445)
            ],
            Self::Combining => &[
                '\u{0300}', // Combining grave accent
                '\u{0301}', // Combining acute accent
                '\u{0302}', // Combining circumflex
                '\u{0303}', // Combining tilde
                '\u{0304}', // Combining macron
                '\u{0305}', // Combining overline
            ],
            Self::Control => &[
                '\u{0000}', // Null
                '\u{0001}', // Start of heading
                '\u{0008}', // Backspace
                '\u{007F}', // Delete
                '\u{0085}', // Next line
                '\u{009F}', // Application program command
            ],
            Self::EmojiZwj => &[
                'üë®', 'üë©', 'üëß', 'üë¶', // Family members
                '\u{200D}', // ZWJ
                '‚ù§', 'üíã', // Connectors
            ],
        }
    }
}

impl PayloadGenerator for UnicodeSpamGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let chars = self.category.chars();
        let mut output = String::with_capacity(self.bytes);
        let mut rng = StdRng::seed_from_u64(42);
        
        let carrier_chars: Vec<char> = self.carrier.chars().collect();
        let mut carrier_idx = 0;
        
        while output.len() < self.bytes {
            // Intersperse carrier text if provided
            if !carrier_chars.is_empty() && rng.gen_bool(0.3) {
                output.push(carrier_chars[carrier_idx % carrier_chars.len()]);
                carrier_idx += 1;
            } else {
                output.push(chars[rng.gen_range(0..chars.len())]);
            }
        }
        
        Ok(GeneratedPayload::Buffered(output.into_bytes()))
    }
    
    fn estimated_size(&self) -> usize {
        // UTF-8 encoding may expand size
        self.bytes * 4
    }
    
    fn name(&self) -> &'static str {
        "unicode_spam"
    }
    
    fn produces_json(&self) -> bool {
        false  // Raw string, needs to be wrapped in JSON
    }
}
```

### F-007: ANSI Escape Generator

The system SHALL generate strings with ANSI escape sequences.

**Acceptance Criteria:**
- Configurable sequence types
- Tests terminal injection attacks
- Valid escape sequence syntax

**Configuration:**
```yaml
response:
  content:
    - type: text
      $generate:
        type: ansi_escape
        sequences:                # List of sequence types
          - cursor_move
          - color
          - title
          - hyperlink
        count: 100                # Number of sequences
        payload: "malicious"      # Text to embed in sequences
```

**Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `sequences` | [enum] | all | Sequence types to include |
| `count` | usize | 100 | Number of sequences |
| `payload` | String | "" | Payload text to embed |

**Sequence Types:**

| Type | Example | Attack |
|------|---------|--------|
| `cursor_move` | `\x1b[H` | Screen manipulation |
| `color` | `\x1b[31m` | Display confusion |
| `title` | `\x1b]0;title\x07` | Terminal title injection |
| `hyperlink` | `\x1b]8;;url\x07text\x1b]8;;\x07` | Phishing |
| `clear` | `\x1b[2J` | Output hiding |

**Implementation:**
```rust
pub struct AnsiEscapeGenerator {
    pub sequences: Vec<AnsiSequenceType>,
    pub count: usize,
    pub payload: String,
}

#[derive(Debug, Clone, Copy)]
pub enum AnsiSequenceType {
    CursorMove,
    Color,
    Title,
    Hyperlink,
    Clear,
}

impl AnsiSequenceType {
    fn generate(&self, payload: &str, rng: &mut impl Rng) -> String {
        match self {
            Self::CursorMove => format!("\x1b[{};{}H", rng.gen_range(1..100), rng.gen_range(1..100)),
            Self::Color => format!("\x1b[{}m", rng.gen_range(30..48)),
            Self::Title => format!("\x1b]0;{}\x07", payload),
            Self::Hyperlink => format!("\x1b]8;;{}\x07click\x1b]8;;\x07", payload),
            Self::Clear => "\x1b[2J\x1b[H".to_string(),
        }
    }
}

impl PayloadGenerator for AnsiEscapeGenerator {
    fn generate(&self) -> Result<GeneratedPayload, GeneratorError> {
        let mut output = String::new();
        let mut rng = StdRng::seed_from_u64(42);
        
        for _ in 0..self.count {
            let seq_type = &self.sequences[rng.gen_range(0..self.sequences.len())];
            output.push_str(&seq_type.generate(&self.payload, &mut rng));
        }
        
        Ok(GeneratedPayload::Buffered(output.into_bytes()))
    }
    
    fn estimated_size(&self) -> usize {
        self.count * 20 + self.payload.len() * self.count
    }
    
    fn name(&self) -> &'static str {
        "ansi_escape"
    }
    
    fn produces_json(&self) -> bool {
        false
    }
}
```

### F-008: Safety Limits

The system SHALL enforce safety limits on generated payloads.

**Acceptance Criteria:**
- Maximum payload size enforced
- Maximum nesting depth enforced
- Limits configurable via environment variables
- Clear error messages when limits exceeded
- Limits checked before generation (via estimated_size)

**Default Limits:**

| Limit | Environment Variable | Default | Description |
|-------|---------------------|---------|-------------|
| Max payload size | `THOUGHTJACK_MAX_PAYLOAD_BYTES` | 100 MB | Maximum generated payload |
| Max nesting depth | `THOUGHTJACK_MAX_NEST_DEPTH` | 100,000 | Maximum JSON nesting |
| Max batch size | `THOUGHTJACK_MAX_BATCH_SIZE` | 100,000 | Maximum batch array size |
| Max key count | `THOUGHTJACK_MAX_KEY_COUNT` | 100,000 | Maximum object keys |

**Implementation:**
```rust
#[derive(Debug, Clone)]
pub struct GeneratorLimits {
    pub max_payload_bytes: usize,
    pub max_nest_depth: usize,
    pub max_batch_size: usize,
    pub max_key_count: usize,
}

impl Default for GeneratorLimits {
    fn default() -> Self {
        Self {
            max_payload_bytes: 100 * 1024 * 1024,  // 100 MB
            max_nest_depth: 100_000,
            max_batch_size: 100_000,
            max_key_count: 100_000,
        }
    }
}

impl GeneratorLimits {
    pub fn from_env() -> Self {
        Self {
            max_payload_bytes: env_or("THOUGHTJACK_MAX_PAYLOAD_BYTES", 100 * 1024 * 1024),
            max_nest_depth: env_or("THOUGHTJACK_MAX_NEST_DEPTH", 100_000),
            max_batch_size: env_or("THOUGHTJACK_MAX_BATCH_SIZE", 100_000),
            max_key_count: env_or("THOUGHTJACK_MAX_KEY_COUNT", 100_000),
        }
    }
    
    pub fn check(&self, generator: &dyn PayloadGenerator) -> Result<(), GeneratorError> {
        let estimated = generator.estimated_size();
        if estimated > self.max_payload_bytes {
            return Err(GeneratorError::PayloadTooLarge {
                estimated,
                limit: self.max_payload_bytes,
            });
        }
        Ok(())
    }
}
```

### F-009: Streaming Generation

The system SHALL support streaming generation for large payloads.

**Acceptance Criteria:**
- Payloads > 1 MB use streaming
- Chunks are reasonably sized (64KB default)
- Memory usage bounded regardless of payload size
- Streaming integrates with transport layer

**Implementation:**
```rust
pub struct GarbageStream {
    remaining: usize,
    charset: Charset,
    rng: StdRng,
    chunk_size: usize,
}

impl GarbageStream {
    pub fn new(total_bytes: usize, charset: Charset, seed: u64) -> Self {
        Self {
            remaining: total_bytes,
            charset,
            rng: StdRng::seed_from_u64(seed),
            chunk_size: 64 * 1024,  // 64 KB chunks
        }
    }
}

#[async_trait]
impl PayloadStream for GarbageStream {
    async fn next_chunk(&mut self) -> Option<Result<Vec<u8>, GeneratorError>> {
        if self.remaining == 0 {
            return None;
        }
        
        let chunk_size = self.chunk_size.min(self.remaining);
        let chunk: Vec<u8> = (0..chunk_size)
            .map(|_| self.charset.sample(&mut self.rng))
            .collect();
        
        self.remaining -= chunk_size;
        Some(Ok(chunk))
    }
    
    fn total_size(&self) -> Option<usize> {
        Some(self.remaining)
    }
}
```

### F-010: Generator Caching

The system SHALL cache generated payloads for reuse.

**Acceptance Criteria:**
- Same generator config produces same cached result
- Cache key based on generator parameters
- Cache respects memory limits
- Cache can be disabled via config

**Implementation:**
```rust
pub struct GeneratorCache {
    cache: HashMap<u64, Arc<GeneratedPayload>>,
    max_cached_bytes: usize,
    current_bytes: usize,
}

impl GeneratorCache {
    pub fn get_or_generate(
        &mut self,
        generator: &dyn PayloadGenerator,
    ) -> Result<Arc<GeneratedPayload>, GeneratorError> {
        let key = self.compute_key(generator);
        
        if let Some(cached) = self.cache.get(&key) {
            return Ok(cached.clone());
        }
        
        let payload = generator.generate()?;
        let size = payload.size();
        
        // Only cache if fits in memory budget
        if size <= self.max_cached_bytes - self.current_bytes {
            let payload = Arc::new(payload);
            self.cache.insert(key, payload.clone());
            self.current_bytes += size;
            Ok(payload)
        } else {
            Ok(Arc::new(payload))
        }
    }
    
    fn compute_key(&self, generator: &dyn PayloadGenerator) -> u64 {
        // Hash generator name and parameters
        let mut hasher = DefaultHasher::new();
        generator.name().hash(&mut hasher);
        // Additional parameter hashing would go here
        hasher.finish()
    }
}
```

### F-011: Deterministic Generation

The system SHALL ensure deterministic payload generation with meaningful variation.

**Acceptance Criteria:**
- Same parameters always produce same output
- RNG seeded from config or hardcoded default
- Seed can be specified per-generator via `seed` parameter
- Useful for reproducible test cases

**Per-Generator Seeding:**

Each generator accepts an optional `seed` parameter. If omitted, a hardcoded default seed is used (e.g., `0xDEADBEEF`).

```yaml
# Explicit seeds for reproducibility:
tools:
  - tool: { name: a }
    response:
      content:
        - $generate: { type: garbage, bytes: 100, seed: 111 }
        - $generate: { type: garbage, bytes: 100, seed: 222 }
  - tool: { name: b }
    response:
      content:
        - $generate: { type: garbage, bytes: 100 }  # Uses default seed
```

**Implementation:**
```rust
impl GarbageGenerator {
    const DEFAULT_SEED: u64 = 0xDEAD_BEEF;

    fn generate_deterministic(&self) -> Vec<u8> {
        let seed = self.seed.unwrap_or(Self::DEFAULT_SEED);
        let mut rng = StdRng::seed_from_u64(seed);

        (0..self.bytes)
            .map(|_| self.charset.sample(&mut rng))
            .collect()
    }
}
```

> **Future Enhancement:** Derived seeding (global_seed + location_hash) could be added if users need automatic unique seeds per generator without explicit configuration.

---

## 3. Edge Cases

### EC-GEN-001: Zero Depth Nested JSON

**Scenario:** `nested_json` with `depth: 0`  
**Expected:** Returns just the inner value (no nesting)

### EC-GEN-002: Nested JSON Depth Exceeds Limit

**Scenario:** `nested_json` with `depth: 1000000` exceeds `THOUGHTJACK_MAX_NEST_DEPTH`  
**Expected:** Validation error at config load time

### EC-GEN-003: Empty Batch

**Scenario:** `batch_notifications` with `count: 0`  
**Expected:** Validation error: "count must be positive"

### EC-GEN-004: Garbage With Zero Bytes

**Scenario:** `garbage` with `bytes: 0`  
**Expected:** Returns empty byte array (valid edge case)

### EC-GEN-005: Unicode Spam Binary Charset

**Scenario:** `unicode_spam` category produces invalid UTF-8  
**Expected:** Control characters are valid UTF-8, but may cause issues

### EC-GEN-006: Repeated Keys Collision Mode Unknown

**Scenario:** `repeated_keys` with `collision_mode: unknown`  
**Expected:** Validation error: "unknown collision_mode"

### EC-GEN-007: Nested JSON With Large Inner Value

**Scenario:** `nested_json` with 1MB inner value  
**Expected:** Works correctly; total size = inner + nesting overhead

### EC-GEN-008: ANSI Escape Empty Sequences List

**Scenario:** `ansi_escape` with `sequences: []`  
**Expected:** Validation error: "sequences cannot be empty"

### EC-GEN-009: Streaming Generator Partial Read

**Scenario:** Caller reads half of streamed payload then stops  
**Expected:** No resource leak; stream cleans up on drop

### EC-GEN-010: Cache Eviction Under Pressure

**Scenario:** Cache is full, new large payload generated  
**Expected:** New payload not cached (no eviction, just skip caching)

### EC-GEN-011: Same Seed Different Generators

**Scenario:** Two garbage generators with same seed but different sizes  
**Expected:** First N bytes are identical (deterministic)

### EC-GEN-012: Nested JSON Object vs Array Size

**Scenario:** `nested_json` object vs array at same depth  
**Expected:** Object is larger (key overhead); size estimate accurate

### EC-GEN-013: Batch Notifications With Complex Params

**Scenario:** `batch_notifications` with deeply nested params object  
**Expected:** Each notification includes full params; size estimate accurate

### EC-GEN-014: Unicode Spam With Empty Carrier

**Scenario:** `unicode_spam` with `carrier: ""`  
**Expected:** Pure Unicode characters, no carrier text

### EC-GEN-015: Repeated Keys Value Is Object

**Scenario:** `repeated_keys` with `value: { "nested": "object" }`  
**Expected:** Each key maps to the full object

### EC-GEN-016: Generator Produces Non-UTF8 for Text Field

**Scenario:** `garbage` with `charset: binary` used in text response field  
**Expected:** Validation warning; may cause JSON encoding issues

### EC-GEN-017: Extremely Long Key in Repeated Keys

**Scenario:** `repeated_keys` with `key_length: 100000`  
**Expected:** Works but check against max_payload_bytes limit

### EC-GEN-018: ANSI Escape Payload Contains Escape Chars

**Scenario:** `ansi_escape` with `payload: "\x1b[31m"`  
**Expected:** Double-escaping creates nested ANSI sequences

### EC-GEN-019: Mixed Nested Structure Odd Depth

**Scenario:** `nested_json` with `structure: mixed, depth: 5`  
**Expected:** Alternates object/array correctly: `{[{[{inner}]}]}`

### EC-GEN-020: Concurrent Generation Same Parameters

**Scenario:** Two threads generate same payload simultaneously  
**Expected:** Both get correct result; cache handles race correctly

---

## 4. Non-Functional Requirements

### NFR-001: Generation Performance

- 10,000-level nested JSON SHALL generate in < 100ms
- 1 MB garbage SHALL generate in < 50ms
- 100,000 batch notifications SHALL generate in < 500ms

### NFR-002: Memory Efficiency

- Streaming generators SHALL use < 1 MB memory regardless of output size
- Cache SHALL respect configured memory limit
- No unbounded allocations during generation

### NFR-003: Determinism

- Same parameters + seed SHALL always produce identical output
- Output SHALL be byte-for-byte identical across runs

### NFR-004: Validation Speed

- Limit checking (estimated_size) SHALL complete in < 1ms
- All validations run at config load time, not runtime

---

## 5. Generator Configuration Reference

### 5.1 Complete Schema

```yaml
$generate:
  # Nested JSON
  type: nested_json
  depth: 10000                  # Required: nesting levels
  structure: object             # object | array | mixed
  key: "a"                      # Key name (for objects)
  inner: null                   # Inner value
  
  # Batch Notifications
  type: batch_notifications
  count: 10000                  # Required: notification count
  method: "notifications/progress"
  params: { ... }
  
  # Garbage
  type: garbage
  bytes: 1048576                # Required: byte count
  charset: ascii                # ascii | binary | alphanumeric
  seed: 12345                   # RNG seed
  
  # Repeated Keys
  type: repeated_keys
  count: 10000                  # Required: key count
  key_length: 8                 # Key string length
  value: "x"                    # Value for each key
  collision_mode: djb2          # djb2 | fnv1a | sequential
  
  # Unicode Spam
  type: unicode_spam
  bytes: 10000                  # Required: approximate size
  category: zero_width          # zero_width | rtl_override | homoglyphs | combining | control | emoji_zwj
  carrier: "safe text"          # Text to intersperse
  
  # ANSI Escape
  type: ansi_escape
  sequences:                    # Required: sequence types
    - cursor_move
    - color
    - title
    - hyperlink
    - clear
  count: 100                    # Number of sequences
  payload: "click here"         # Embedded payload
```

### 5.2 Usage in Tool Response

```yaml
tool:
  name: "data_export"
  description: "Export data"
  inputSchema:
    type: object
    properties:
      format: { type: string }

response:
  content:
    - type: text
      text: "Export complete. Data:"
    - type: text
      $generate:
        type: garbage
        bytes: 10485760         # 10 MB of garbage
        charset: ascii
```

### 5.3 Usage in Phase Entry

```yaml
phases:
  - name: dos_phase
    on_enter:
      - send_notification: notifications/tools/list_changed
    replace_tools:
      data_tool:
        tool:
          name: data_tool
          # ...
        response:
          content:
            - type: text
              $generate:
                type: nested_json
                depth: 50000
```

---

## 6. Implementation Notes

### 6.1 Recommended Libraries

| Library | Purpose |
|---------|---------|
| `rand` | Random number generation |
| `rand::SeedableRng` | Deterministic seeding |
| `serde_json` | JSON construction |
| `tokio::sync::RwLock` | Cache synchronization |
| `indexmap` | Deterministic iteration order for generated objects |

### 6.2 Generator Factory

```rust
pub fn create_generator(config: &GenerateConfig) -> Result<Box<dyn PayloadGenerator>, ConfigError> {
    match config.generator_type.as_str() {
        "nested_json" => Ok(Box::new(NestedJsonGenerator {
            depth: config.get_required("depth")?,
            structure: config.get_or("structure", NestedStructure::Object),
            key: config.get_or("key", "a".to_string()),
            inner: config.get_or("inner", serde_json::Value::Null),
        })),
        "batch_notifications" => Ok(Box::new(BatchNotificationsGenerator {
            count: config.get_required("count")?,
            method: config.get_or("method", "notifications/message".to_string()),
            params: config.get("params"),
        })),
        "garbage" => Ok(Box::new(GarbageGenerator {
            bytes: config.get_required("bytes")?,
            charset: config.get_or("charset", Charset::Ascii),
            seed: config.get_or("seed", 0),
        })),
        "repeated_keys" => Ok(Box::new(RepeatedKeysGenerator {
            count: config.get_required("count")?,
            key_length: config.get_or("key_length", 8),
            value: config.get_or("value", serde_json::json!("x")),
            collision_mode: config.get_or("collision_mode", CollisionMode::Djb2),
        })),
        "unicode_spam" => Ok(Box::new(UnicodeSpamGenerator {
            bytes: config.get_required("bytes")?,
            category: config.get_required("category")?,
            carrier: config.get_or("carrier", String::new()),
        })),
        "ansi_escape" => Ok(Box::new(AnsiEscapeGenerator {
            sequences: config.get_required("sequences")?,
            count: config.get_or("count", 100),
            payload: config.get_or("payload", String::new()),
        })),
        unknown => Err(ConfigError::UnknownGenerator(unknown.to_string())),
    }
}
```

### 6.3 Anti-Patterns

| Anti-Pattern | Why | Correct Approach |
|--------------|-----|------------------|
| Materializing generators at config load | OOM on large payloads | Store generator factory, generate at response time |
| Recursive JSON construction | Stack overflow at high depth | Iterative construction |
| Unbounded string concatenation | O(n¬≤) performance | Pre-allocate with capacity |
| Ignoring estimated_size | OOM on large payloads | Check limits before generating |
| Global mutable RNG | Non-deterministic, races | Per-generator seeded RNG |
| Caching streamed payloads | Defeats streaming purpose | Only cache buffered payloads |
| Silent truncation at limits | Confusing behavior | Explicit error on limit exceeded |
| Using `HashMap` for ordered output | Non-deterministic iteration order | Use `IndexMap` or `BTreeMap` |

### 6.4 Testing Strategy

**Unit Tests:**
- Each generator produces expected output format
- Determinism: same seed = same output
- Edge cases: zero, min, max values
- Limit enforcement

**Property Tests:**
- Generated JSON is syntactically valid
- Generated Unicode is valid UTF-8
- Size estimates are within 10% of actual

**Benchmark Tests:**
- Generation time at various sizes
- Memory usage during streaming
- Cache hit/miss performance

---

## 7. Definition of Done

- [ ] `PayloadGenerator` trait implemented
- [ ] `NestedJsonGenerator` implemented (object, array, mixed)
- [ ] `BatchNotificationsGenerator` implemented with streaming
- [ ] `GarbageGenerator` implemented with all charsets
- [ ] `RepeatedKeysGenerator` implemented with collision modes
- [ ] `UnicodeSpamGenerator` implemented with all categories
- [ ] `AnsiEscapeGenerator` implemented with all sequence types
- [ ] Safety limits enforced via `GeneratorLimits`
- [ ] Streaming works for payloads > 1 MB
- [ ] Caching works with memory limits
- [ ] Deterministic generation with seed
- [ ] All generators produce valid output format
- [ ] All 20 edge cases (EC-GEN-001 through EC-GEN-020) have tests
- [ ] Generation performance meets NFR-001
- [ ] Memory efficiency meets NFR-002
- [ ] Determinism verified (NFR-003)
- [ ] Validation speed meets NFR-004
- [ ] `cargo clippy -- -D warnings` passes
- [ ] `cargo test` passes

---

## 8. References

- [TJ-SPEC-001: Configuration Schema](./TJ-SPEC-001_Configuration_Schema.md)
- [TJ-SPEC-004: Behavioral Modes](./TJ-SPEC-004_Behavioral_Modes.md)
- [Hash Collision DoS](https://www.youtube.com/watch?v=R2Cq3CLI6H8)
- [Unicode Security Considerations](https://unicode.org/reports/tr36/)
- [ANSI Escape Sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
- [JSON Parser Security](https://seriot.ch/projects/parsing_json.html)

---

## Appendix A: Attack Coverage Matrix

| Attack ID | Generator | Configuration | Target Vulnerability |
|-----------|-----------|---------------|---------------------|
| TAM-001 | `nested_json` | `depth: 100000` | Parser stack overflow |
| TAM-002 | `batch_notifications` | `count: 100000` | Batch processing limits |
| CPM-003 | `unicode_spam` | `category: zero_width` | Filter bypass, hidden text |
| CPM-004 | `ansi_escape` | `sequences: [title, hyperlink]` | Terminal injection |
| ‚Äî | `garbage` | `bytes: 100000000` | Memory exhaustion |
| ‚Äî | `repeated_keys` | `count: 100000, collision_mode: djb2` | Hash table DoS |

---

## Appendix B: Size Estimation Formulas

| Generator | Formula | Example |
|-----------|---------|---------|
| `nested_json` (object) | `depth * (5 + key_len) + inner_size` | 10000 * 6 + 4 = 60,004 bytes |
| `nested_json` (array) | `depth * 2 + inner_size` | 10000 * 2 + 4 = 20,004 bytes |
| `batch_notifications` | `count * notification_size + count + 2` | 10000 * 80 + 10002 = 810,002 bytes |
| `garbage` | `bytes` | 1048576 bytes |
| `repeated_keys` | `count * (key_len + 4 + value_size) + 2` | 10000 * 15 + 2 = 150,002 bytes |
| `unicode_spam` | `bytes * 4` (worst case UTF-8) | 10000 * 4 = 40,000 bytes max |
| `ansi_escape` | `count * 20 + payload_len * count` | 100 * 20 + 10 * 100 = 3,000 bytes |

---

## Appendix C: Unicode Category Details

### Zero Width Characters

| Character | Code Point | Name |
|-----------|------------|------|
| ‚Äã | U+200B | Zero Width Space |
| ‚Äå | U+200C | Zero Width Non-Joiner |
| ‚Äç | U+200D | Zero Width Joiner |
| Ôªø | U+FEFF | Byte Order Mark |
| ‚Å† | U+2060 | Word Joiner |

### Homoglyph Examples

| Latin | Cyrillic | Code Points |
|-------|----------|-------------|
| a | –∞ | U+0061 vs U+0430 |
| e | –µ | U+0065 vs U+0435 |
| o | –æ | U+006F vs U+043E |
| p | —Ä | U+0070 vs U+0440 |
| c | —Å | U+0063 vs U+0441 |
| x | —Ö | U+0078 vs U+0445 |

### Combining Character Stacking

```
Base + Combining = Rendered
'e' + U+0301 = '√©' (one combining mark)
'e' + U+0301 + U+0302 + U+0303 = '√©ÃÇÃÉ' (stacked marks - rendering issues)
'e' + (U+0301 √ó 100) = potential buffer overflow
```
